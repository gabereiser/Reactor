using System;
using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using Reactor.Fonts;

namespace Reactor.Loaders
{
  /// <summary>
  /// Parsing class for bitmap fonts generated by AngelCode BMFont
  /// </summary>
  public static class BitmapFontLoader
  {
    #region Public Methods
    /// <summary>
    /// Load font information from the specified <see cref="Stream"/>.
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <exception cref="ArgumentException">Thrown when one or more arguments have unsupported or
    /// illegal values.</exception>
    /// <exception cref="InvalidDataException">Thrown when an Invalid Data error condition occurs.</exception>
    /// <param name="stream">The stream to load.</param>
    public static BitmapFont Load(Stream stream)
    {
      if (stream == null)
      {
        throw new ArgumentNullException(nameof(stream));
      }

      if (!stream.CanSeek)
      {
        throw new ArgumentException("Stream must be seekable in order to determine file format.", nameof(stream));
      }

      switch (BitmapFontLoader.GetFileFormat(stream))
      {
        case BitmapFontFormat.Binary:
          return LoadBinary(stream);
          break;

        case BitmapFontFormat.Text:
          return LoadText(stream);
          break;

        case BitmapFontFormat.Xml:
          return LoadXml(stream);
          break;

        default:
          throw new InvalidDataException("Unknown file format.");
      }
    }

    /// <summary>
    /// Load font information from the specified file.
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <exception cref="FileNotFoundException">Thrown when the requested file is not present.</exception>
    /// <param name="fileName">The file name to load.</param>
    public static BitmapFont Load(string fileName)
    {
      BitmapFont f;
      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException(nameof(fileName));
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'.", fileName), fileName);
      }

      using (Stream stream = File.OpenRead(fileName))
      {
        f = Load(stream);
      }

      BitmapFont.QualifyResourcePaths(f, Path.GetDirectoryName(fileName));
      return f;
    }

    /// <summary>
    /// Loads font information from the specified stream.
    /// </summary>
    /// <remarks>
    /// The source data must be in BMFont binary format.
    /// </remarks>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <param name="stream">The stream containing the font to load.</param>
    public static BitmapFont LoadBinary(Stream stream)
    {
      var f = new BitmapFont();
      byte[] buffer;

      if (stream == null)
      {
        throw new ArgumentNullException(nameof(stream));
      }

      buffer = new byte[1024];

      // The first three bytes are the file identifier and must always be 66, 77, 70, or "BMF". The fourth byte gives the format version, currently it must be 3.

      stream.Read(buffer, 0, 4);

      if (buffer[0] != 66 || buffer[1] != 77 || buffer[2] != 70)
      {
        throw new InvalidDataException("Source steam does not contain BMFont data.");
      }

      if (buffer[3] != 3)
      {
        throw new InvalidDataException("Only BMFont version 3 format data is supported.");
      }

      f.InvalidChar = Character.Empty;

      // Following the first four bytes is a series of blocks with information. Each block starts with a one byte block type identifier, followed by a 4 byte integer that gives the size of the block, not including the block type identifier and the size value.

      while (stream.Read(buffer, 0, 5) != 0)
      {
        byte blockType;
        int blockSize;

        blockType = buffer[0];

        blockSize = WordHelpers.MakeDWordLittleEndian(buffer, 1);
        if (blockSize > buffer.Length)
        {
          buffer = new byte[blockSize];
        }

        if (stream.Read(buffer, 0, blockSize) != blockSize)
        {
          throw new InvalidDataException("Failed to read enough data to fill block.");
        }

        switch (blockType)
        {
          case 1: // Block type 1: info
            LoadInfoBlock(ref f, buffer);
            break;

          case 2: // Block type 2: common
            LoadCommonBlock(ref f, buffer);
            break;

          case 3: // Block type 3: pages
            LoadPagesBlock(ref f, buffer);
            break;

          case 4: // Block type 4: chars
            LoadCharactersBlock(ref f, buffer, blockSize);
            break;

          case 5: // Block type 5: kerning pairs
            LoadKerningsBlock(ref f, buffer, blockSize);
            break;

          default: throw new InvalidDataException("Block type " + blockType + " is not a valid BMFont block");
        }
      }

      return f;
    }

    /// <summary>
    /// Loads font information from the specified string.
    /// </summary>
    /// <param name="text">String containing the font to load.</param>
    /// <remarks>The source data must be in BMFont text format.</remarks>
    public static BitmapFont LoadText(string text)
    {
      using (StringReader reader = new StringReader(text))
      {
        return LoadText(reader);
      }
    }

    /// <summary>
    /// Loads font information from the specified stream.
    /// </summary>
    /// <remarks>
    /// The source data must be in BMFont text format.
    /// </remarks>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <param name="stream">The stream containing the font to load.</param>
    public static BitmapFont LoadText(Stream stream)
    {
      if (stream == null)
      {
        throw new ArgumentNullException(nameof(stream));
      }

      using (TextReader reader = new StreamReader(stream))
      {
        return LoadText(reader);
      }
    }
    /// <summary> Loads a bitmap font stored in binary format. </summary>
    /// <exception cref="ArgumentNullException"> Thrown when one or more required arguments are null. </exception>
    /// <exception cref="FileNotFoundException"> Thrown when the requested file is not present. </exception>
    /// <param name="fileName"> Name of the file to load. </param>
    /// <returns> A <see cref="BitmapFont"/> containing the loaded data. </returns>
    public static BitmapFont LoadFontFromBinaryFile(string fileName)
    {
      BitmapFont font;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException(nameof(fileName));
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }

      

      using (Stream stream = File.OpenRead(fileName))
      {
        font = LoadBinary(stream);
      }

      BitmapFont.QualifyResourcePaths(font, Path.GetDirectoryName(fileName));

      return font;
    }

    /// <summary> Loads a bitmap font from a file, attempting to auto detect the file type. </summary>
    /// <exception cref="ArgumentNullException"> Thrown when one or more required arguments are null. </exception>
    /// <exception cref="FileNotFoundException"> Thrown when the requested file is not present. </exception>
    /// <exception cref="InvalidDataException"> Thrown when an Invalid Data error condition occurs. </exception>
    /// <param name="fileName"> Name of the file to load. </param>
    /// <returns> A <see cref="BitmapFont"/> containing the loaded data. </returns>
    public static BitmapFont LoadFontFromFile(string fileName)
    {
      BitmapFont result;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException(nameof(fileName), "File name not specified");
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }

      switch (BitmapFontLoader.GetFileFormat(fileName))
      {
        case BitmapFontFormat.Binary:
          result = BitmapFontLoader.LoadFontFromBinaryFile(fileName);
          break;

        case BitmapFontFormat.Text:
          result = BitmapFontLoader.LoadFontFromTextFile(fileName);
          break;

        case BitmapFontFormat.Xml:
          result = BitmapFontLoader.LoadFontFromXmlFile(fileName);
          break;

        default:
          throw new InvalidDataException("Unknown file format.");
      }

      return result;
    }

    /// <summary> Loads a bitmap font from a file containing font data in text format. </summary>
    /// <exception cref="ArgumentNullException"> Thrown when one or more required arguments are null. </exception>
    /// <exception cref="FileNotFoundException"> Thrown when the requested file is not present. </exception>
    /// <param name="fileName"> Name of the file to load. </param>
    /// <returns> A <see cref="BitmapFont"/> containing the loaded data. </returns>
    public static BitmapFont LoadFontFromTextFile(string fileName)
    {
      BitmapFont font;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException(nameof(fileName));
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }



      using (Stream stream = File.OpenRead(fileName))
      {
        font = LoadText(stream);
      }

      BitmapFont.QualifyResourcePaths(font, Path.GetDirectoryName(fileName));

      return font;
    }

    /// <summary> Loads a bitmap font from a file containing font data in XML format. </summary>
    /// <exception cref="ArgumentNullException"> Thrown when one or more required arguments are null. </exception>
    /// <exception cref="FileNotFoundException"> Thrown when the requested file is not present. </exception>
    /// <param name="fileName"> Name of the file to load. </param>
    /// <returns> A <see cref="BitmapFont"/> containing the loaded data. </returns>
    public static BitmapFont LoadFontFromXmlFile(string fileName)
    {
      BitmapFont font;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException(nameof(fileName));
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }
      
      using (Stream stream = File.OpenRead(fileName))
      {
        font = LoadXml(stream);
      }

      BitmapFont.QualifyResourcePaths(font, Path.GetDirectoryName(fileName));

      return font;
    }

    #endregion Public Methods

    #region Internal Methods

    /// <summary> Attempts to determine the format of the given font file. </summary>
    /// <param name="fileName"> Name of the file to test. </param>
    /// <returns> The file format. </returns>
    internal static BitmapFontFormat GetFileFormat(string fileName)
    {
      using (Stream stream = File.OpenRead(fileName))
      {
        return BitmapFontLoader.GetFileFormat(stream);
      }
    }

    /// <summary> Attempts to determine the format of the given font file. </summary>
    /// <param name="stream"> The <see cref="Stream"/> containing the font information. </param>
    /// <returns> The file format. </returns>
    internal static BitmapFontFormat GetFileFormat(Stream stream)
    {
      BitmapFontFormat result;
      byte[] buffer;
      long position;

      buffer = new byte[5];
      position = stream.Position;

      stream.Read(buffer, 0, 5);

      stream.Position = position;

      if (buffer[0] == 66 && buffer[1] == 77 && buffer[2] == 70 && buffer[3] == 3)
      {
        result = BitmapFontFormat.Binary;
      }
      else if (buffer[0] == 105 && buffer[1] == 110 && buffer[2] == 102 && buffer[3] == 111 && buffer[4] == 32)
      {
        result = BitmapFontFormat.Text;
      }
      else if (buffer[0] == 60 && buffer[1] == 63 && buffer[2] == 120 && buffer[3] == 109 && buffer[4] == 108)
      {
        result = BitmapFontFormat.Xml;
      }
      else
      {
        result = BitmapFontFormat.None;
      }

      return result;
    }

    /// <summary> Returns a boolean from an array of name/value pairs. </summary>
    /// <param name="parts">  The array of parts. </param>
    /// <param name="name"> The name of the value to return. </param>
    /// <param name="estimatedStart"> The estimated position in the part array where the value is located. </param>
    /// <returns> The parsed value, or <c>false</c> if not found </returns>
    internal static bool GetNamedBool(string[] parts, string name, int estimatedStart)
    {
      return int.TryParse(BitmapFontLoader.GetNamedString(parts, name, estimatedStart), NumberStyles.Number, CultureInfo.InvariantCulture, out int v) && v > 0;
    }

    /// <summary>
    /// Returns an integer from an array of name/value pairs.
    /// </summary>
    /// <param name="parts">The array of parts.</param>
    /// <param name="name">The name of the value to return.</param>
    /// <param name="estimatedStart"> The estimated position in the part array where the value is located. </param>
    /// <returns> The parsed value, or <c>0</c> if not found </returns>
    internal static int GetNamedInt(string[] parts, string name, int estimatedStart)
    {
      return int.TryParse(BitmapFontLoader.GetNamedString(parts, name, estimatedStart), NumberStyles.Number, CultureInfo.InvariantCulture, out int result) ? result : 0;
    }

    /// <summary>
    /// Returns a string from an array of name/value pairs.
    /// </summary>
    /// <param name="parts">The array of parts.</param>
    /// <param name="name">The name of the value to return.</param>
    /// <param name="estimatedStart"> The estimated position in the part array where the value is located. </param>
    /// <returns> The parsed value, or the empty string if not found </returns>
    internal static string GetNamedString(string[] parts, string name, int estimatedStart)
    {
      string result;

      if (string.Equals(BitmapFontLoader.GetValueName(parts[estimatedStart]), name, StringComparison.OrdinalIgnoreCase))
      {
        // we have a value right were we expected it
        result = BitmapFontLoader.SanitizeValue(parts[estimatedStart].Substring(name.Length + 1));
      }
      else
      {
        // we didn't find a value at our estimated position
        // so enumerate the full array looking for the value

        result = string.Empty;

        for (int i = 0; i < parts.Length; i++)
        {
          string part;

          part = parts[i];

          if (string.Equals(BitmapFontLoader.GetValueName(part), name, StringComparison.OrdinalIgnoreCase))
          {
            result = BitmapFontLoader.SanitizeValue(part.Substring(name.Length + 1));
            break;
          }
        }
      }

      return result;
    }

    /// <summary>
    /// Creates a Padding object from a string representation
    /// </summary>
    /// <param name="s">The string.</param>
    /// <returns></returns>
    internal static Padding ParsePadding(string s)
    {
      int rStart;
      int bStart;
      int lStart;

      rStart = s.IndexOf(',');
      bStart = s.IndexOf(',', rStart + 1);
      lStart = s.IndexOf(',', bStart + 1);

      return new Padding
      (
        int.Parse(s.Substring(lStart + 1), CultureInfo.InvariantCulture),
        int.Parse(s.Substring(0, rStart), CultureInfo.InvariantCulture),
        int.Parse(s.Substring(rStart + 1, bStart - rStart - 1), CultureInfo.InvariantCulture),
        int.Parse(s.Substring(bStart + 1, lStart - bStart - 1), CultureInfo.InvariantCulture)
      );
    }

    /// <summary>
    /// Creates a Point object from a string representation
    /// </summary>
    /// <param name="s">The string.</param>
    /// <returns></returns>
    internal static Point ParsePoint(string s)
    {
      int yStart;

      yStart = s.IndexOf(',');

      return new Point
      (
        int.Parse(s.Substring(0, yStart), CultureInfo.InvariantCulture),
        int.Parse(s.Substring(yStart + 1), CultureInfo.InvariantCulture)
      );
    }

/// <summary>
    /// Loads font information from the specified <see cref="TextReader"/>.
    /// </summary>
    /// <remarks>
    /// The source data must be in BMFont text format.
    /// </remarks>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <param name="reader">The <strong>TextReader</strong> used to feed the data into the font.</param>
    public static BitmapFont LoadText(TextReader reader)
    {
      var f = new BitmapFont();
      IDictionary<int, Page> pageData;
      IDictionary<Kerning, int> kerningDictionary;
      IDictionary<char, Character> charDictionary;
      string line;
      string[] parts;

      if (reader == null)
      {
        throw new ArgumentNullException(nameof(reader));
      }

      pageData = new SortedDictionary<int, Page>();
      kerningDictionary = new Dictionary<Kerning, int>();
      charDictionary = new Dictionary<char, Character>();
      parts = new string[13]; // the maximum number of fields on a single line;

      f.InvalidChar = Character.Empty;

      do
      {
        line = reader.ReadLine();

        if (line != null)
        {
          BitmapFontLoader.Split(line, parts);

          if (parts.Length != 0)
          {
            switch (parts[0])
            {
              case "info":
                f.FamilyName = BitmapFontLoader.GetNamedString(parts, "face", 1);
                f.FontSize = BitmapFontLoader.GetNamedInt(parts, "size", 2);
                f.Bold = BitmapFontLoader.GetNamedBool(parts, "bold", 3);
                f.Italic = BitmapFontLoader.GetNamedBool(parts, "italic", 4);
                f.Charset = BitmapFontLoader.GetNamedString(parts, "charset", 5);
                f.Unicode = BitmapFontLoader.GetNamedBool(parts, "unicode", 6);
                f.StretchedHeight = BitmapFontLoader.GetNamedInt(parts, "stretchH", 7);
                f.Smoothed = BitmapFontLoader.GetNamedBool(parts, "smooth", 8);
                f.SuperSampling = BitmapFontLoader.GetNamedInt(parts, "aa", 9);
                f.Padding = BitmapFontLoader.ParsePadding(BitmapFontLoader.GetNamedString(parts, "padding", 10));
                f.Spacing = BitmapFontLoader.ParsePoint(BitmapFontLoader.GetNamedString(parts, "spacing", 11));
                f.OutlineSize = BitmapFontLoader.GetNamedInt(parts, "outline", 12);
                break;

              case "common":
                f.LineHeight = BitmapFontLoader.GetNamedInt(parts, "lineHeight", 1);
                f.BaseHeight = BitmapFontLoader.GetNamedInt(parts, "base", 2);
                f.TextureSize = new Size(BitmapFontLoader.GetNamedInt(parts, "scaleW", 3),
                                            BitmapFontLoader.GetNamedInt(parts, "scaleH", 4));
                // TODO: 5 is pages, which we currently don't directly read
                f.Packed = BitmapFontLoader.GetNamedBool(parts, "packed", 6);
                f.AlphaChannel = BitmapFontLoader.GetNamedInt(parts, "alphaChnl", 7);
                f.RedChannel = BitmapFontLoader.GetNamedInt(parts, "redChnl", 8);
                f.GreenChannel = BitmapFontLoader.GetNamedInt(parts, "greenChnl", 9);
                f.BlueChannel = BitmapFontLoader.GetNamedInt(parts, "blueChnl", 10);
                break;

              case "page":
                int id;
                string name;

                id = BitmapFontLoader.GetNamedInt(parts, "id", 1);
                name = BitmapFontLoader.GetNamedString(parts, "file", 2);

                pageData.Add(id, new Page(id, name));
                break;

              case "char":
                Character charData;
                int index;

                index = BitmapFontLoader.GetNamedInt(parts, "id", 1);

                charData = new Character
                (
                  index >= 0 ? (char)index : '\0',
                  BitmapFontLoader.GetNamedInt(parts, "x", 2),
                  BitmapFontLoader.GetNamedInt(parts, "y", 3),
                  BitmapFontLoader.GetNamedInt(parts, "width", 4),
                  BitmapFontLoader.GetNamedInt(parts, "height", 5),
                  BitmapFontLoader.GetNamedInt(parts, "xoffset", 6),
                  BitmapFontLoader.GetNamedInt(parts, "yoffset", 7),
                  BitmapFontLoader.GetNamedInt(parts, "xadvance", 8),
                  BitmapFontLoader.GetNamedInt(parts, "page", 9),
                  BitmapFontLoader.GetNamedInt(parts, "chnl", 10)
                );

                if (index == -1)
                {
                  f.InvalidChar = charData;
                }

                charDictionary.Add(charData.Char, charData);
                break;

              case "kerning":
                Kerning key;

                key = new Kerning((char)BitmapFontLoader.GetNamedInt(parts, "first", 1),
                                  (char)BitmapFontLoader.GetNamedInt(parts, "second", 2),
                                  BitmapFontLoader.GetNamedInt(parts, "amount", 3));

                if (!kerningDictionary.ContainsKey(key))
                {
                  kerningDictionary.Add(key, key.Amount);
                }
                break;
            }
          }
        }
      } while (line != null);

      f.Pages = BitmapFontLoader.ToArray(pageData.Values);
      f.Characters = charDictionary;
      f.Kernings = kerningDictionary;
      return f;
    }

    /// <summary>
    /// Loads font information from the specified string.
    /// </summary>
    /// <param name="xml">String containing the font to load.</param>
    /// <remarks>The source data must be in BMFont XML format.</remarks>
    public static BitmapFont LoadXml(string xml)
    {
      using (StringReader reader = new StringReader(xml))
      {
        return LoadXml(reader);
      }
    }

    /// <summary>
    /// Loads font information from the specified <see cref="TextReader"/>.
    /// </summary>
    /// <remarks>
    /// The source data must be in BMFont XML format.
    /// </remarks>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <param name="reader">The <strong>TextReader</strong> used to feed the data into the font.</param>
    public static BitmapFont LoadXml(TextReader reader)
    {
      var f = new BitmapFont();
      XmlDocument document;
      IDictionary<int, Page> pageData;
      IDictionary<Kerning, int> kerningDictionary;
      IDictionary<char, Character> charDictionary;
      XmlNode root;
      XmlNode properties;

      if (reader == null)
      {
        throw new ArgumentNullException(nameof(reader));
      }

      document = new XmlDocument();
      pageData = new SortedDictionary<int, Page>();
      kerningDictionary = new Dictionary<Kerning, int>();
      charDictionary = new Dictionary<char, Character>();

      document.Load(reader);
      root = document.DocumentElement;

      f.InvalidChar = Character.Empty;

      // load the basic attributes
      properties = root.SelectSingleNode("info");
      f.FamilyName = properties.Attributes["face"].Value;
      f.FontSize = Convert.ToInt32(properties.Attributes["size"].Value, CultureInfo.InvariantCulture);
      f.Bold = Convert.ToInt32(properties.Attributes["bold"].Value, CultureInfo.InvariantCulture) != 0;
      f.Italic = Convert.ToInt32(properties.Attributes["italic"].Value, CultureInfo.InvariantCulture) != 0;
      f.Unicode = Convert.ToInt32(properties.Attributes["unicode"].Value, CultureInfo.InvariantCulture) != 0;
      f.StretchedHeight = Convert.ToInt32(properties.Attributes["stretchH"].Value, CultureInfo.InvariantCulture);
      f.Charset = properties.Attributes["charset"].Value;
      f.Smoothed = Convert.ToInt32(properties.Attributes["smooth"].Value, CultureInfo.InvariantCulture) != 0;
      f.SuperSampling = Convert.ToInt32(properties.Attributes["aa"].Value, CultureInfo.InvariantCulture);
      f.Padding = ParsePadding(properties.Attributes["padding"].Value);
      f.Spacing = ParsePoint(properties.Attributes["spacing"].Value);
      f.OutlineSize = Convert.ToInt32(properties.Attributes["outline"].Value, CultureInfo.InvariantCulture);

      // common attributes
      properties = root.SelectSingleNode("common");
      f.BaseHeight = Convert.ToInt32(properties.Attributes["base"].Value, CultureInfo.InvariantCulture);
      f.LineHeight = Convert.ToInt32(properties.Attributes["lineHeight"].Value, CultureInfo.InvariantCulture);
      f.TextureSize = new Size(Convert.ToInt32(properties.Attributes["scaleW"].Value, CultureInfo.InvariantCulture),
                                  Convert.ToInt32(properties.Attributes["scaleH"].Value, CultureInfo.InvariantCulture));
      f.Packed = Convert.ToInt32(properties.Attributes["packed"].Value, CultureInfo.InvariantCulture) != 0;
      f.AlphaChannel = Convert.ToInt32(properties.Attributes["alphaChnl"].Value, CultureInfo.InvariantCulture);
      f.RedChannel = Convert.ToInt32(properties.Attributes["redChnl"].Value, CultureInfo.InvariantCulture);
      f.GreenChannel = Convert.ToInt32(properties.Attributes["greenChnl"].Value, CultureInfo.InvariantCulture);
      f.BlueChannel = Convert.ToInt32(properties.Attributes["blueChnl"].Value, CultureInfo.InvariantCulture);

      // load texture information
      foreach (XmlNode node in root.SelectNodes("pages/page"))
      {
        Page page;

        page = new Page(Convert.ToInt32(node.Attributes["id"].Value, CultureInfo.InvariantCulture), node.Attributes["file"].Value);

        pageData.Add(page.Id, page);
      }
      f.Pages = BitmapFontLoader.ToArray(pageData.Values);

      // load character information
      foreach (XmlNode node in root.SelectNodes("chars/char"))
      {
        Character character;
        int index;

        index = Convert.ToInt32(node.Attributes["id"].Value, CultureInfo.InvariantCulture);

        character = new Character(
        index >= 0 ? (char)index : '\0',
        Convert.ToInt32(node.Attributes["x"].Value, CultureInfo.InvariantCulture),
        Convert.ToInt32(node.Attributes["y"].Value, CultureInfo.InvariantCulture),
        Convert.ToInt32(node.Attributes["width"].Value, CultureInfo.InvariantCulture),
        Convert.ToInt32(node.Attributes["height"].Value, CultureInfo.InvariantCulture),
        Convert.ToInt32(node.Attributes["xoffset"].Value, CultureInfo.InvariantCulture),
        Convert.ToInt32(node.Attributes["yoffset"].Value, CultureInfo.InvariantCulture),
        Convert.ToInt32(node.Attributes["xadvance"].Value, CultureInfo.InvariantCulture),
        Convert.ToInt32(node.Attributes["page"].Value, CultureInfo.InvariantCulture),
        Convert.ToInt32(node.Attributes["chnl"].Value, CultureInfo.InvariantCulture)
        );

        if (index == -1)
        {
          f.InvalidChar = character;
        }

        charDictionary.Add(character.Char, character);
      }
      f.Characters = charDictionary;

      // loading kerning information
      foreach (XmlNode node in root.SelectNodes("kernings/kerning"))
      {
        Kerning key;

        key = new Kerning((char)Convert.ToInt32(node.Attributes["first"].Value, CultureInfo.InvariantCulture),
                          (char)Convert.ToInt32(node.Attributes["second"].Value, CultureInfo.InvariantCulture),
                          Convert.ToInt32(node.Attributes["amount"].Value, CultureInfo.InvariantCulture));

        if (!kerningDictionary.ContainsKey(key))
        {
          kerningDictionary.Add(key, key.Amount);
        }
      }
      f.Kernings = kerningDictionary;
      return f;
    }

    /// <summary>
    /// Loads font information from the specified stream.
    /// </summary>
    /// <remarks>
    /// The source data must be in BMFont XML format.
    /// </remarks>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <param name="stream">The stream containing the font to load.</param>
    public static BitmapFont LoadXml(Stream stream)
    {
      if (stream == null)
      {
        throw new ArgumentNullException(nameof(stream));
      }

      using (TextReader reader = new StreamReader(stream))
      {
        return LoadXml(reader);
      }
    }


    /// <summary>
    /// Splits the specified string using a given delimiter, ignoring any instances of the delimiter as part of a quoted string.
    /// </summary>
    /// <param name="s">The string to split.</param>
    /// <param name="buffer">The output buffer where split strings will be placed. Must be larged enough to handle the contents of <paramref name="s"/>.</param>
    /// <returns></returns>
    internal static void Split(string s, string[] buffer)
    {
      int index;
      int partStart;
      char delimiter;

      index = 0;
      partStart = -1;
      delimiter = ' ';

      do
      {
        int partEnd;
        int quoteStart;
        int quoteEnd;
        int length;
        bool hasQuotes;

        quoteStart = s.IndexOf('"', partStart + 1);
        quoteEnd = s.IndexOf('"', quoteStart + 1);
        partEnd = s.IndexOf(delimiter, partStart + 1);

        if (partEnd == -1)
        {
          partEnd = s.Length;
        }

        hasQuotes = quoteStart != -1 && partEnd > quoteStart && partEnd < quoteEnd;
        if (hasQuotes)
        {
          partEnd = s.IndexOf(delimiter, quoteEnd + 1);

          if (partEnd == -1)
          {
            partEnd = s.Length;
          }
        }

        length = partEnd - partStart - 1;
        if (length > 0)
        {
          buffer[index] = s.Substring(partStart + 1, length);
          index++;
        }

        if (hasQuotes)
        {
          partStart = partEnd - 1;
        }

        partStart = s.IndexOf(delimiter, partStart + 1);
      } while (partStart != -1);

      // reset any unused parts of the buffer
      for (; index < buffer.Length; index++)
      {
        buffer[index] = string.Empty;
      }
    }

    /// <summary>
    /// Converts the given collection into an array
    /// </summary>
    /// <typeparam name="T">Type of the items in the array</typeparam>
    /// <param name="values">The values.</param>
    /// <returns></returns>
    internal static T[] ToArray<T>(ICollection<T> values)
    {
      T[] result;

      // avoid a forced .NET 3 dependency just for one call to Linq

      result = new T[values.Count];
      values.CopyTo(result, 0);

      return result;
    }

    #endregion Internal Methods

    #region Private Methods

    /// <summary> Returns the name from a name value pair. </summary>
    /// <param name="nameValuePair">  The name value pair to parse. </param>
    /// <returns> The extracted name. </returns>
    private static string GetValueName(string nameValuePair)
    {
      int nameEndIndex;

      return !string.IsNullOrEmpty(nameValuePair) && (nameEndIndex = nameValuePair.IndexOf('=')) != -1
        ? nameValuePair.Substring(0, nameEndIndex)
        : null;
    }

    /// <summary> Removes quotes surrounding a string value. </summary>
    /// <param name="value">  The value to sanitize. </param>
    /// <returns> The sanitized string. </returns>
    private static string SanitizeValue(string value)
    {
      int valueLength;

      valueLength = value.Length;

      if (valueLength > 1 && value[0] == '"' && value[valueLength - 1] == '"')
      {
        value = value.Substring(1, valueLength - 2);
      }

      return value;
    }

    private static string GetString(byte[] buffer, int index)
    {
      StringBuilder sb;

      sb = new StringBuilder();

      for (int i = index; i < buffer.Length; i++)
      {
        byte chr;

        chr = buffer[i];

        if (chr == 0)
        {
          break;
        }

        sb.Append((char)chr);
      }

      return sb.ToString();
    }

    private static void LoadCharactersBlock(ref BitmapFont font, byte[] buffer, int blockSize)
    {
      int charCount;
      IDictionary<char, Character> characters;

      charCount = blockSize / 20; // The number of characters in the file can be computed by taking the size of the block and dividing with the size of the charInfo structure, i.e.: numChars = charsBlock.blockSize/20.
      characters = new Dictionary<char, Character>(charCount);

      for (int i = 0; i < charCount; i++)
      {
        int start;
        Character chr;
        int index;

        start = i * 20;

        index = WordHelpers.MakeDWordLittleEndian(buffer, start);

        chr = new Character
        (
          index >= 0 ? (char)index : '\0',
          WordHelpers.MakeWordLittleEndian(buffer, start + 4),
          WordHelpers.MakeWordLittleEndian(buffer, start + 6),
          WordHelpers.MakeWordLittleEndian(buffer, start + 8),
          WordHelpers.MakeWordLittleEndian(buffer, start + 10),
          WordHelpers.MakeWordLittleEndian(buffer, start + 12),
          WordHelpers.MakeWordLittleEndian(buffer, start + 14),
          WordHelpers.MakeWordLittleEndian(buffer, start + 16),
          buffer[start + 18],
          buffer[start + 19]
        );

        if (index == -1)
        {
          font.InvalidChar = chr;
        }

        characters.Add(chr.Char, chr);
      }

      font.Characters = characters;
    }

    private static void LoadCommonBlock(ref BitmapFont font, byte[] buffer)
    {
      font.LineHeight = WordHelpers.MakeWordLittleEndian(buffer, 0);
      font.BaseHeight = WordHelpers.MakeWordLittleEndian(buffer, 2);
      font.TextureSize = new Size(WordHelpers.MakeWordLittleEndian(buffer, 4), WordHelpers.MakeWordLittleEndian(buffer, 6));
      font.Pages = new Page[WordHelpers.MakeWordLittleEndian(buffer, 8)];
      font.AlphaChannel = buffer[11];
      font.RedChannel = buffer[12];
      font.GreenChannel = buffer[13];
      font.BlueChannel = buffer[14];
    }

    private static void LoadInfoBlock(ref BitmapFont font, byte[] buffer)
    {
      byte bits;

      font.FontSize = WordHelpers.MakeWordLittleEndian(buffer, 0);
      bits = buffer[2]; // 	bit 0: smooth, bit 1: unicode, bit 2: italic, bit 3: bold, bit 4: fixedHeigth, bits 5-7: reserved
      font.Smoothed = (bits & (1 << 7)) != 0;
      font.Unicode = (bits & (1 << 6)) != 0;
      font.Italic = (bits & (1 << 5)) != 0;
      font.Bold = (bits & (1 << 4)) != 0;
      font.Charset = string.Empty; // TODO: buffer[3]
      font.StretchedHeight = WordHelpers.MakeWordLittleEndian(buffer, 4);
      font.SuperSampling = WordHelpers.MakeWordLittleEndian(buffer, 6);
      font.Padding = new Padding(buffer[10], buffer[7], buffer[8], buffer[9]);
      font.Spacing = new Point(buffer[11], buffer[12]);
      font.OutlineSize = buffer[13];
      font.FamilyName = GetString(buffer, 14);
    }

    private static void LoadKerningsBlock(ref BitmapFont font, byte[] buffer, int blockSize)
    {
      int pairCount;
      Dictionary<Kerning, int> kernings;

      pairCount = blockSize / 10;
      kernings = new Dictionary<Kerning, int>(pairCount);

      for (int i = 0; i < pairCount; i++)
      {
        int start;
        Kerning kerning;

        start = i * 10;

        kerning = new Kerning
        (
          (char)WordHelpers.MakeDWordLittleEndian(buffer, start),
          (char)WordHelpers.MakeDWordLittleEndian(buffer, start + 4),
          WordHelpers.MakeWordLittleEndian(buffer, start + 8)
        );

        kernings.Add(kerning, kerning.Amount);
      }

      font.Kernings = kernings;
    }

    private static void LoadPagesBlock(ref BitmapFont font, byte[] buffer)
    {
      int nextStringStart;

      nextStringStart = 0;

      for (int i = 0; i < font.Pages.Length; i++)
      {
        Page page;
        string name;

        page = font.Pages[i];

        name = GetString(buffer, nextStringStart);
        nextStringStart += name.Length + 1; // +1 for the null terminator

        page.Id = i;
        page.FileName = name;

        font.Pages[i] = page;
      }
    }
    #endregion Private Methods
  }
}
