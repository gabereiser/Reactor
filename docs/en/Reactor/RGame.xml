<Type Name="RGame" FullName="Reactor.RGame">
  <TypeSignature Language="C#" Value="public abstract class RGame : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit RGame extends System.Object implements class System.IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Reactor</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            Provides a facility for creating a main Game complete with a <see cref="T:Reactor.RGameWindow" />.
            This class must be inherited in your game as the main component.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RGame ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
            Initializes a new instance of the <see cref="T:Reactor.RGame" /> class.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public abstract void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Releases all resource used by the <see cref="T:Reactor.RGame" /> object.  This is where you would also remove any user loaded content.
            </summary>
        <remarks>Call <see cref="M:Reactor.RGame.Dispose" /> when you are finished using the <see cref="T:Reactor.RGame" />. The
            <see cref="M:Reactor.RGame.Dispose" /> method leaves the <see cref="T:Reactor.RGame" /> in an unusable state. After calling
            <see cref="M:Reactor.RGame.Dispose" />, you must release all references to the <see cref="T:Reactor.RGame" /> so the garbage
            collector can reclaim the memory that the <see cref="T:Reactor.RGame" /> was occupying.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Engine">
      <MemberSignature Language="C#" Value="public Reactor.REngine Engine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Reactor.REngine Engine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Reactor.REngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Main Reactor Engine reference.  Use this within your <see cref="T:Reactor.RGame" /> class.
            </summary>
        <value>The engine.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GameWindow">
      <MemberSignature Language="C#" Value="public Reactor.RGameWindow GameWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Reactor.RGameWindow GameWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Reactor.RGameWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The internal game window.
            </summary>
        <value>The game window.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public abstract void Init ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Init() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Override for Initialization code.  Override this and setup the engine in this block.
            </summary>
        <remarks>To be added.</remarks>
        <example>Example of how to initialize the engine with a window of 800x600.
            <code>
            public override void Init()
            {
            Engine.InitGameWindow(800,600);
            // TODO: Initialize more systems and load your content.
            }
            </code></example>
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="public abstract void Render ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Render() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Override for control over rendering.  This is always required.  This will be called everytime a frame needs to be rendered.
            </summary>
        <remarks>To be added.</remarks>
        <example>Example render loop.  Clear must be called first, render anything you wish, then call Present() to swap the back buffer and show it on screen.
            <code>
            public override void Render()
            {
            Engine.Clear();
            // TODO: Render your game objects or call Scene.RenderAll(); if you wish for the scene manager to attempt to render them all.
            Engine.Present();
            }
            </code></example>
      </Docs>
    </Member>
    <Member MemberName="Resized">
      <MemberSignature Language="C#" Value="public abstract void Resized (int Width, int Height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Resized(int32 Width, int32 Height) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Width" Type="System.Int32" />
        <Parameter Name="Height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Width">To be added.</param>
        <param name="Height">To be added.</param>
        <summary>
            Gets called when the underlying <see cref="T:Reactor.RGameWindow" /> is resized;
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Run() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Run the game.  This starts the message pump and loops required to receive events in <see cref="M:Reactor.RGame.Render" /> and <see cref="M:Reactor.RGame.Update" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public abstract void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Update() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Override for control over updating.  This is always required.  This will be called everytime a frame needs updating.
            This is also where you can check for input and things as well.
            </summary>
        <remarks>To be added.</remarks>
        <example>A typical update loop.  Anything your game needs to update should be called within this method.  If an object has an Update() method, it needs to be added somewhere within this method block flow.
            <code>public override void Update()
            {
            camera.Update();
            mesh.Update();
            //etc...
            }
            </code></example>
      </Docs>
    </Member>
  </Members>
</Type>
